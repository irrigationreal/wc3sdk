#!/usr/bin/env python3
"""
Generate a Windows module-definition (.def) file that forwards exports to another module.

Primary use in this repo: build a proxy DLL (e.g. mss32.dll) that runs our code in DllMain,
while forwarding all real API calls to a renamed/original DLL (e.g. Mss32.original.dll).

This script intentionally avoids parsing PE directly (no extra deps). It uses `objdump -p`.
"""

from __future__ import annotations

import argparse
import os
import re
import shutil
import subprocess
import sys
from dataclasses import dataclass


@dataclass(frozen=True)
class Export:
    index: int  # 0-based index into the export address table
    name: str


EXPORT_TABLE_HEADER = "[Ordinal/Name Pointer] Table"


def _run_objdump(path: str) -> str:
    objdump = shutil.which("objdump")
    if not objdump:
        raise RuntimeError("Missing dependency: objdump (binutils). Install it and retry.")

    proc = subprocess.run(
        [objdump, "-p", path],
        check=False,
        stdout=subprocess.PIPE,
        stderr=subprocess.PIPE,
        text=True,
    )
    if proc.returncode != 0:
        raise RuntimeError(f"objdump failed ({proc.returncode}):\n{proc.stderr.strip()}")
    return proc.stdout


def _parse_ordinal_base(objdump_text: str) -> int:
    # Example: "Ordinal Base \t\t\t1"
    for line in objdump_text.splitlines():
        if line.strip().startswith("Ordinal Base"):
            parts = line.strip().split()
            try:
                return int(parts[-1], 10)
            except (ValueError, IndexError) as exc:
                raise RuntimeError(f"Failed to parse ordinal base from line: {line!r}") from exc
    raise RuntimeError("Failed to find 'Ordinal Base' in objdump output.")


def _parse_exports(objdump_text: str) -> list[Export]:
    exports: list[Export] = []
    in_table = False

    # Example lines:
    #   [   0] @stream_background@0
    #   [  66] AIL_debug_printf
    entry_re = re.compile(r"^\s*\[\s*(\d+)\s*\]\s+(.+?)\s*$")

    for line in objdump_text.splitlines():
        if not in_table:
            if line.strip() == EXPORT_TABLE_HEADER:
                in_table = True
            continue

        match = entry_re.match(line)
        if not match:
            # Table ended.
            if exports:
                break
            continue

        index = int(match.group(1), 10)
        name = match.group(2).strip()
        exports.append(Export(index=index, name=name))

    if not exports:
        raise RuntimeError(
            "Failed to parse exports. Expected an '[Ordinal/Name Pointer] Table' section in objdump output."
        )

    # Stable output: sort by index.
    exports.sort(key=lambda e: e.index)
    return exports


def _emit_def(
    exports: list[Export],
    ordinal_base: int,
    library: str,
    forward_module: str,
    source_path: str,
) -> str:
    lines: list[str] = []
    lines.append("; Auto-generated by scripts/gen_proxy_def.py")
    lines.append(f"; Source DLL: {source_path}")
    lines.append(f"; OrdinalBase: {ordinal_base}")
    lines.append(f"; ExportCount: {len(exports)}")
    lines.append("")
    lines.append(f'LIBRARY "{library}"')
    lines.append("EXPORTS")

    for export in exports:
        ordinal = ordinal_base + export.index
        name = export.name
        # Forwarder syntax: ExportName = OtherModule.ExportName @ordinal
        lines.append(f"  {name} = {forward_module}.{name} @{ordinal}")

    lines.append("")
    return "\n".join(lines)


def main(argv: list[str]) -> int:
    parser = argparse.ArgumentParser(
        description="Generate a .def file that forwards all exports to another module (via objdump -p)."
    )
    parser.add_argument("--dll", required=True, help="Path to the source DLL (e.g. Mss32.dll).")
    parser.add_argument(
        "--forward-module",
        required=True,
        help='Forward target module name without extension (e.g. "Mss32.original").',
    )
    parser.add_argument(
        "--library",
        required=True,
        help='Library name to embed in the .def (e.g. "mss32.dll").',
    )
    parser.add_argument("--out", required=True, help="Output .def file path.")
    args = parser.parse_args(argv)

    dll_path = os.path.abspath(args.dll)
    if not os.path.isfile(dll_path):
        print(f"Not a file: {dll_path}", file=sys.stderr)
        return 2

    objdump_text = _run_objdump(dll_path)
    ordinal_base = _parse_ordinal_base(objdump_text)
    exports = _parse_exports(objdump_text)

    out_path = os.path.abspath(args.out)
    os.makedirs(os.path.dirname(out_path), exist_ok=True)

    def_text = _emit_def(
        exports=exports,
        ordinal_base=ordinal_base,
        library=args.library,
        forward_module=args.forward_module,
        source_path=dll_path,
    )

    with open(out_path, "w", encoding="utf-8", newline="\n") as f:
        f.write(def_text)

    print(f"Wrote: {out_path}")
    print(f"Exports: {len(exports)}")
    print(f"Ordinal base: {ordinal_base}")
    print(f"Forward module: {args.forward_module}")
    print(f"Library: {args.library}")
    return 0


if __name__ == "__main__":
    raise SystemExit(main(sys.argv[1:]))

