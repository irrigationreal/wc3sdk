use std::env;
use std::fs;
use std::path::{Path, PathBuf};
use std::process::Command;

const EXPORT_TABLE_HEADER: &str = "[Ordinal/Name Pointer] Table";

#[derive(Debug)]
struct Export {
    index: u32,
    name: String,
}

fn main() {
    let target = env::var("TARGET").unwrap_or_default();
    if !target.contains("windows") {
        return;
    }

    let source_dll = env::var("WC3_MSS32_SOURCE_DLL").unwrap_or_else(|_| {
        panic!(
            "WC3_MSS32_SOURCE_DLL is required when building wc3-proxy-mss32 for Windows.\n\
             Example:\n\
               export WC3_MSS32_SOURCE_DLL=\"/mnt/storage/Warcraft 3/Mss32.dll\""
        )
    });

    if !Path::new(&source_dll).is_file() {
        panic!("WC3_MSS32_SOURCE_DLL is not a file: {source_dll}");
    }

    let forward_module =
        env::var("WC3_MSS32_FORWARD_MODULE").unwrap_or_else(|_| "Mss32.original".to_string());

    let library_name =
        env::var("WC3_MSS32_LIBRARY_NAME").unwrap_or_else(|_| "mss32.dll".to_string());

    let objdump = env::var("OBJDUMP").unwrap_or_else(|_| "objdump".to_string());

    let out_dir = PathBuf::from(env::var_os("OUT_DIR").expect("OUT_DIR must be set"));
    let def_path = out_dir.join("mss32-forward.def");

    let objdump_text = run_objdump(&objdump, Path::new(&source_dll));
    let ordinal_base = parse_ordinal_base(&objdump_text);
    let mut exports = parse_exports(&objdump_text);
    exports.sort_by_key(|e| e.index);

    let def_text = emit_def(
        &def_path,
        &source_dll,
        ordinal_base,
        &library_name,
        &forward_module,
        &exports,
    );
    fs::write(&def_path, def_text).expect("write def file");

    // In MinGW builds, passing the .def as a linker input file is enough.
    // (MSVC would need /DEF:<path> instead.)
    if target.ends_with("-msvc") {
        println!("cargo:rustc-link-arg=/DEF:{}", def_path.display());
    } else {
        println!("cargo:rustc-link-arg={}", def_path.display());
    }

    // Re-run build script if the source DLL changes.
    println!("cargo:rerun-if-env-changed=WC3_MSS32_SOURCE_DLL");
    println!("cargo:rerun-if-env-changed=WC3_MSS32_FORWARD_MODULE");
    println!("cargo:rerun-if-env-changed=WC3_MSS32_LIBRARY_NAME");
    println!("cargo:rerun-if-changed={}", source_dll);
}

fn run_objdump(objdump: &str, dll_path: &Path) -> String {
    let output = Command::new(objdump)
        .arg("-p")
        .arg(dll_path)
        .output()
        .unwrap_or_else(|e| panic!("failed to run {objdump}: {e}"));

    if !output.status.success() {
        let stderr = String::from_utf8_lossy(&output.stderr);
        panic!("objdump failed: {stderr}");
    }

    String::from_utf8_lossy(&output.stdout).into_owned()
}

fn parse_ordinal_base(objdump_text: &str) -> u32 {
    for line in objdump_text.lines() {
        let trimmed = line.trim();
        if trimmed.starts_with("Ordinal Base") {
            let last = trimmed.split_whitespace().last().expect("ordinal base value");
            return last.parse::<u32>().expect("ordinal base int");
        }
    }
    panic!("Failed to find 'Ordinal Base' in objdump output");
}

fn parse_exports(objdump_text: &str) -> Vec<Export> {
    let mut exports = Vec::new();
    let mut in_table = false;

    for line in objdump_text.lines() {
        if !in_table {
            if line.trim() == EXPORT_TABLE_HEADER {
                in_table = true;
            }
            continue;
        }

        // Expected: [  66] AIL_debug_printf
        let trimmed = line.trim_start();
        if !trimmed.starts_with('[') {
            if !exports.is_empty() {
                break;
            }
            continue;
        }

        let Some(close) = trimmed.find(']') else {
            continue;
        };
        let idx_part = &trimmed[1..close];
        let name_part = trimmed[close + 1..].trim();

        if name_part.is_empty() {
            continue;
        }

        let index = idx_part.trim().parse::<u32>().expect("export index int");
        exports.push(Export {
            index,
            name: name_part.to_string(),
        });
    }

    if exports.is_empty() {
        panic!("Failed to parse export table from objdump output");
    }

    exports
}

fn emit_def(
    def_path: &Path,
    source_dll: &str,
    ordinal_base: u32,
    library_name: &str,
    forward_module: &str,
    exports: &[Export],
) -> String {
    let mut s = String::new();
    s.push_str("; Auto-generated by crates/proxy-mss32/build.rs\n");
    s.push_str(&format!("; Output: {}\n", def_path.display()));
    s.push_str(&format!("; Source DLL: {source_dll}\n"));
    s.push_str(&format!("; OrdinalBase: {ordinal_base}\n"));
    s.push_str(&format!("; ExportCount: {}\n", exports.len()));
    s.push('\n');
    s.push_str(&format!("LIBRARY \"{library_name}\"\n"));
    s.push_str("EXPORTS\n");

    for export in exports {
        let ordinal = ordinal_base + export.index;
        let name = &export.name;
        s.push_str(&format!("  {name} = {forward_module}.{name} @{ordinal}\n"));
    }

    s
}
